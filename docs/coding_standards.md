# 共通コーディング理念

## 基本原則

### 1. 最新記述の優先
- **関数コンポーネント** > クラスコンポーネント
- **async/await** > Promise.then()
- **Arrow Function** > 通常の関数宣言
- **const/let** > var
- **Template Literals** > 文字列結合

### 2. パフォーマンス優先
- **不要な再レンダリング防止**: React.memo、useMemo、useCallback
- **効率的なデータ構造**: 適切なコレクション選択
- **メモリリーク防止**: useEffectのクリーンアップ
- **最適化**: インデックス、キャッシュ、遅延読み込み

### 3. 最小限機能実装
- **YAGNI原則**: 必要になるまで実装しない
- **単一責任**: 1つの関数・コンポーネントは1つの責任のみ
- **過度な抽象化を避ける**: 必要以上の汎用化をしない

## 記述スタイル

### 変数・関数
- **const優先**: 再代入しない変数はconst
- **分割代入**: オブジェクト・配列の分割代入を積極活用
- **早期リターン**: ネストを減らし、条件分岐を明確化
- **純粋関数**: 副作用のない関数を心がける

### 型・エラーハンドリング
- **明示的な型注釈**: TypeScriptでは型を明確に
- **Optional Chain**: ?. 演算子でnullチェック
- **try-catch**: async/awaitでのエラーハンドリング

### API・データ処理
- **RESTful**: 標準的なHTTPメソッドとステータスコード
- **入力検証**: 全ての外部入力をバリデーション
- **一貫したレスポンス形式**: JSON形式で統一

## セキュリティ・品質

### セキュリティ
- **デフォルト拒否**: 権限は最小限から開始
- **機密情報**: 環境変数で管理、ログに出力しない
- **サニタイズ**: 全ての外部入力を無害化

### 可読性
- **意味のある命名**: 省略せず、目的を明確に
- **自己文書化**: コードが自ら説明できる状態
- **DRY原則**: 重複コードを避け、再利用可能な実装

## 開発効率

### 共通処理
- **再利用可能なコンポーネント**: 共通UIパターンの抽出
- **ユーティリティ関数**: 頻繁に使用する処理の共通化
- **設定の一元化**: 定数・設定値の管理

これらの原則は、コード品質・保守性・パフォーマンスを向上させる指針です。
